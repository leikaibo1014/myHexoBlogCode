---
title: 作业帮面试整理
date: 2020-06-09 22:26:32
tags: [java,面试，作业帮]
categories: 面试整理
copyright: true
toc: true

---



## Linux常用命令

  <!-- more -->



## 一面： 

- 1.自我介绍 

- 2.讲讲之前实习是做了什么工作 

- 3.项目做了什么，为什么做这个项目，有什么困难，如何解决，结果是什么。 

- 看你项目中遇到的困难在缓存和数据库，那你项目的后端框架用的是什么，数据库的底层数据结构是什么，磁盘的数据结构是什么？ 

- . B+树的结构是什么，和B树有什么区别，红黑树结构是什么？

- 红黑树的应用有哪些？AVL树是什么，平衡二叉树的条件是什么？ 



#### 一、B树的应用

 

### 1、B树大量应用在数据库和文件系统当中。

 

它的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数。B树算法减少定位记录时所经历的中间过程，从而加快存取速度。

 

假定一个节点可以容纳100个值，那么3层的B树可以容纳100万个数据，如果换成二叉查找树，则需要20层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在100万个数据中查找目标值，只需要读取两次硬盘。

 

如mongoDB数据库使用，单次查询平均快于Mysql（但侧面来看Mysql至少平均查询耗时差不多）

 

#### 二、B+树的应用

 

mysql使用B+树作为索引：

 

B+树相对B树的优点：

 

①B+树的所有Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串联起来，遍历叶子节点就能获取全部数据，这样就能进行区间访问了。

 

②IO一次读数据是从磁盘上读的，磁盘容量是固定的，取数据量大小是固定的，非叶子节点不存储数据，节点小，磁盘IO次数就少。

InnoDB索引和MyISAM最大的区别是它只有一个数据文件，在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点数据域保存了完整的数据记录。所以我们又把它的主索引叫做聚集索引。而它的辅助索引和MyISAM也会有所不同，它的辅助索引都是将主键作为数据域。所以，这样当我们查找的时候通过辅助索引要先找到主键，然后通过主索引再找到对于的主键，得到信息。

 

MyISAM表索引在处理文本索引时更具优势，而INNODB表索引在其它类型上更具效率优势，同时MySQL高并发需要事务场景时，只能使用INNODB表



### 三、红黑树

 

红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况在数据较小，可以完全放到内存中时，红黑树的时间复杂度比B树低。

 

如linux中进程的调度用的是红黑树。

反之，数据量较大，外存中占主要部分时，B树因其读磁盘次数少，而具有更快的速度。

 

 

### 哈希表用什么解决冲突的？ 

拉链法

8. - 拉链法解决冲突可以，但是如果链表变长，如何优化呢？

HashMap采用位桶+链表+红黑树实现，当链表长度超过阈值（8）,时，将链表转换为红黑树，这样大大减少了查找时间。

一直到JDK7为止，HashMap的结构都是这么简单，基于一个数组以及多个链表的实现，hash值冲突的时候，就将对应节点以链表的形式存储。

这样子的HashMap性能上就抱有一定疑问，如果说成百上千个节点在hash时发生碰撞，存储一个链表中，那么如果要查找其中一个节点，那就不可避免的花费O(N)的查找时间，这将是多么大的性能损失。这个问题终于在JDK8中得到了解决。再最坏的情况下，链表查找的时间复杂度为O(n),而红黑树一直是O(logn),这样会提高HashMap的效率。



## 如果优化为树结构，数据量依旧很大，如何进一步优化？

 

### 10 数据库读写分离机制，如何做分库分表的？用的什么中间件去分库分表？ 

 

11.如何确保数据库的稳定性 

12.算法：链表反转 

13.有什么要问我的？

 

 

### 1.自我介绍 

### 2.做过哪些项目，给自己印象最深的项目是什么 

### 3.用redis做二级缓存的时候如何确保高并发数据的一致性，如果有一张订单表，我要你找到对应用户所拥有的订单，怎么找？

 

 

数据库的几种事务隔离机制是什么，有哪些？有什么用？ 

 

mysql支持事务的常用引擎是InnoDB

第一种：读未提交（read uncommitted）

 

　　　　　　第一个事务未提交更新的数据，第二个事务可以读到，这是读未提				交。

　　　　　　第一个事务未提交更新的数据回滚，第二个事务读到回滚的数据，				这是脏读。故读未提交，可能会出现脏读。

第二种：读已提交（read committed），也称不可重复读

 

　　　　　　第一个事务未提交更新的数据，第二个事务读不到；

　　　　　　第一个事务提交更新的数据，第二个事务可以读到；这是读已提交。

　　　　　　第一个事务提交更新小明同学年龄12岁，第二个事务读到小明12				岁；

第三个事务再次提交更新小明同学年龄14岁，第二个事务再读到小明14岁；这是不可重复读（同一个事务内读取的数据结果不一致）。

 

　　　　　　故读已提交，会出现不可重复读（同一个事务内读取的数据结果不			一致），不可重复读也会造成幻读（同一个事务内读取的数据结果			不一致）。

 

第三种：可重复读（repeatable read），mysql默认事务隔离级别

第一个事务提交更新小明同学年龄12岁，第二个事务读到小明12岁；

第三个事务再次提交更新小明同学年龄14岁，第二个事务再读到小明12岁；这是可重复读（同一个事务内读取的数据结果一致）。

第四个事务提交插入同学小马数据记录，第二个事务再读不仅读到小明12	岁数据，还会读到小马同学数据，这是幻读。

故可重复读，会出现幻读（同一个事务内读取的数据结果不一致）。

第四种：串行化（serializable）

隔离级别最高，解决了脏读、不可重复无、幻读问题。

　　　　　　同一个事务内，不管读取多少次，结果集永远一致。

 



### Str1=“a” str2=new string(“a”)区别，虚拟机内存空间上如何体现这两个区别，这区别具体在开发中会造成什么问题，如何解决？ 

- ==:比较引用类型比较的是地址值是否相同

- equals:比较引用类型默认也是比较地址值是否相同，注意:***\*String类重写了equals()方法\****，比较的是内容是否相同。



String A = "ABC";内存会去查找永久代(常量池) ，如果没有的话，在永久代中中开辟一块儿内存空间，把地址付给栈指针，如果已经有了"ABC"的内存，直接把地址赋给栈指针；\****

***\*而String str = new String("a");是根据"a"这个String对象再次构造一个String对象;在堆中从新new一块儿内存，把指针赋给栈，\****

 

堆  栈  变量的存放位置



### Java和C++在内存处理上有什么区别？虚拟机的常用垃圾回收机制有什么？

 

###  什么时候会发生OOM错误（内存溢出错误） 

栈溢出，堆溢出

栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口灯信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）

 

所以我们可以理解为栈溢出就是方法执行是创建的栈帧超过了栈的深度。那么最有可能的就是方法递归调用产生这种结果。

heap space表示堆空间，堆中主要存储的是对象。如果不断的new对象则会导致堆中的空间溢出

 

### Redis的基本数据结构是什么？ 

### redis如何做持久化的？ 

### 给你一个场景，设计秒杀系统，假设有10件商品， 先用redis去get数量，数量-1，然后用set更新redis的数据，如果get数据为0就表示商品卖完了，这种情况安全么，有问题的话如何解决 

 

 

### redis加锁上锁的命令是什么 

#### Linux awk grep命令是什么，如何用正则表达式匹配AxxxxAxxx？（正则还是用的比较少 生疏了。。。） 

 

 ### 讲一下在浏览器输入URL之后到浏览器出现界面的全过程，系统后面用了哪些协议

- 首先进行域名解析，域名解析具体过程讲一下：

- 浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表；操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。

- 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。

- 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，则操作系统将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，通过以下方式迭代查找：

- 本地域名服务器向根域名服务器发起请求，根域名服务器返回com域的顶级域名服务器的地址；

- 本地域名服务器向com域的顶级域名服务器发起请求，返回权限域名服务器地址；

- 本地域名服务器向权限域名服务器发起请求，得到IP地址；

 

- 本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来；

- 操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来；

- 至此，浏览器已经得到了域名对应的IP地址。

 

2. 浏览器发起HTTP请求；

 

3. 接下来到了传输层，选择传输协议，TCP或者UDP，TCP是可靠的传输控制协议，对HTTP请求进行封装，加入了端口号等信息--三次握手建立连接--四次挥手断开连接；

4. 然后到了网络层，通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址；

5. 接下来到了数据链路层，把网络层交下来的IP数据报添加首部和尾部，封装为MAC帧，现在根据目的mac开始建立TCP连接，三次握手，接收端在收到物理层上交的比特流后，根据首尾的标记，识别帧的开始和结束，将中间的数据部分上交给网络层，然后层层向上传递到应用层；

6. 服务器响应请求并请求客户端要的资源，传回给客户端；

7. 断开TCP连接，浏览器对页面进行渲染呈现给客户端。

 

 

#### 如果你有很多IP地址，如何找到出现次数最多的前三个IP地址？（hashMap + heap） 

- 1.直接排序

- 2.使用hashTable  我们的算法就有了：维护一个Key为Query字串，Value为该Query出现次数的HashTable，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内完成了对该海量数据的处理。

- 本方法相比算法1：在时间复杂度上提高了一个数量级，为O（N），但不仅仅是时间复杂度上的优化，该方法只需要IO数据文件一次，而算法1的IO次数较多的，因此该算法2比算法1在工程上有更好的可操作性。

 



### 如果你有一个100G的IP地址文件，你的机器只有5G存储空间，如何找到出现次数最多的前三IP地址？ 

 

 

### 如果一张订单表特别大，你会如何处理这个表格，如何优化它？

 

### 我们一般都是把历史数据定期转存其他表（一样的表名后加年月例如TABLE201205）归档~

这样该表本年度的查询的压力也小点（90%查询量集中在本年度）,即使查询历史数据也不影响性能，强力推荐！

 

#### 算法题：字符串切分+反转 

 

```java

public class reverseString {
    public static void main(String[] args) {
        // i am a student
        String string = "i am a student";
        String s = reverseDemo(string);
        System.out.println(s);

    }
    public static String reverseDemo(String string){
        String[] strArr = string.split(" ");
        String[] resultArr = new String[strArr.length];

        StringBuffer stringBuffer = new StringBuffer();

        for (int i=0;i<strArr.length;i++){
            resultArr[i] = strArr[strArr.length - i - 1];
            if (i != strArr.length - 1) {
                stringBuffer.append(resultArr[i]);
                stringBuffer.append(" ");
            }else {
                stringBuffer.append(resultArr[i]);
            }
        }
        return stringBuffer.toString();
    }
}

```



 

### 16.盲人有10双袜子，两双黑的，8双白的，如何在没人帮助下找出黑的（在太阳下晒一晒黑色更吸热） 

### 17.你有什么问题想问我的？

 

### MYSQL日志分为几种

https://blog.csdn.net/xiamiflying/article/details/80960598

如何保证回滚


数据库中事务到底是mvcc回滚还是日志回滚


### socket有几种状态

##### Socket 11种状态

- 1、SOCKET状态介绍

socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口;HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。

  1、客户端独有的：（1）SYN_SENT （2）FIN_WAIT1 （3）FIN_WAIT2 （4）CLOSING （5）TIME_WAIT 。

  2、服务器独有的：（1）LISTEN （2）SYN_RCVD （3）CLOSE_WAIT （4）LAST_ACK 。

  3、共有的：（1）CLOSED （2）ESTABLISHED 。



##### mysql更新了数据日志文件有什么改变
##### 它的意思是服务器崩了，你访问服务器应该是什么样
服务器崩了发送什么错误码，崩了情况下500是谁发的
开发环境和生产环境不一样，配置环境应该有什么不同配置数据库
ACID
死锁以及解决措施

rabbitmq中各种模式
堆栈区别
GC回收算法
点击按钮这个过程详解一下



### 算法题：
长字符串相加
nums[] = {1,-1,0,2,-2,1,3} 找到所有不重复a + b + c = 0



```java
暴力解法，而且重复
public class zifuJia {
    public static void main(String[] args) {
         int[] array = {1,-1,0,2,-2,1,3};
        List list = stringSum(array);

        System.out.println(list);
    }
    public static List stringSum(int[] array){
        List<List<Integer>> list = new ArrayList();

        Arrays.sort(array);
        for (int i = 0; i < array.length; i++) {
            if (i > 1 && array[i] == array[i - 1]) {
                continue;
            }
            for (int j = i + 1; j < array.length; j++) {
                for (int k = j + 1; k < array.length; k++) {
                    if (array[i] + array[j] + array[k] == 0) {

                       list.add(Arrays.asList(array[i], array[j], array[k]));
                    }
                }
            }
        }
        for (int i = 0; i < list.size()-1; i++) {
            if (list.get(i).equals(list.get(i+1))){
                list.remove(list.get(i + 1));
            }
        }
        return list;
    }
}
```



 

#### 堆排序：



```java

public class heapSort {
    public static void main(String[] args) {
        int[] array = {12,15,10,18,6,9,16};
        heap_sort(array, array.length);
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i]+" ");
        }

    }

    /**
     * 参数说明   arr 表示待构建数组
     * n：表示堆的元素个数
     * i: 表示每一个小堆的父节点
     */
    public static void heap_step(int[] arr, int n, int i) {
        int c1 = 2 * i + 1;    //i结点的左孩子
        int c2 = 2 * i + 2;   //i结点的右孩子
        int max = i;   //这三个元素最大值的下标指向

        //定义递归出口
        if (i > n) {
            return;
        }
        if (c1 < n && arr[c1] > arr[max]){
            max = c1;
        }
        if (c2 < n && arr[c2] > arr[max]) {
            max = c2;
        }
        if (max != i) {
            swap(arr, max, i);//交换两个位置的元素
            heap_step(arr, n, max);//继续进行递归判断，确保每一次构建完任意一个小堆都是大顶堆
        }

    }

    /**
     * 我们需要对每一个非叶子结点以及他们的左右孩子构建大顶堆
     * 从最后一个非叶子结点开始
     * 最后一个叶子结点数组下标为：  last_node = arr.length-1
     * 则最后一个非叶子结点为   last_parent = (last_node-1)/2
     * @param arr
     * @param n
     */
    public static void build_heap(int[] arr, int n) {
        int last_node = n-1;
        int last_parent = (last_node-1)/2;
        //对每一个非叶子结点，依次从后向前遍历，每一个都做heap_step的大顶堆构建
        for (int i = last_parent; i >=0 ; i--) {
            heap_step(arr,n,i);
        }
    }

    /**
     * 构建完大顶堆之后，需要进行大顶堆的第一个元素与最后元素进行交换
     * @param arr
     */
    public static void heap_sort(int[] arr,int n){
        build_heap(arr, arr.length);   //把数组先构造成为一个大顶堆
        // 这个时候数组已经是一个大顶堆了
        //交换数据
        for (int i = n - 1; i >= 0; i--) {
            swap(arr, i, 0);
            /*
                因为这个时候完全二叉树已经是一个大顶堆了，
                所以我们只需要使用heap_step交换最顶层的三个数字就可以,也就是最根节点以及它们的左右孩子节点
             */
            heap_step(arr, i, 0);
        }

    }


    /*
        两个元素交换位置的函数
     */
    public static void swap(int[] arr,int i,int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

```



 

##### 快速排序;



问了项目，单点登录实现 

 

如何解决分布式session 

 

redis集群怎么做的，主从复制流程 

RDB和AOF，如果AOF文件很大怎么办，AOF重做，还是特别大怎么办，分片复制 

 

#### TCP三次握手四次挥手 

三次挥手行不行，为什么 

#### 状态码301与302的区别 

详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了）

301 redirect: 301 代表永久性转移(Permanently Moved)

302 redirect: 302 代表暂时性转移(Temporarily Moved )

 

#### Linux找到文件夹下包含某个字符的所有记录 

grep -r message ./

示例解释：在当前目录下递归查找含有字符串message的文件

-r 是递归查找

 

-n 是显示行号

-R 查找所有文件包含子目录

-i 忽略大小写

 

### 分页查询页数很大效率低怎么办，join 连接主键优化 

select * from orders_history where type=8 limit 100000,100;

***\*这种分页查询方式会从数据库第一条记录开始扫描，所以越往后，查询速度越慢，而且查询的数据越多，也会拖慢总查询速度。\****

**(1)** ***\*使用子查询优化--\****这种方式先定位偏移位置的 id，然后往后查询，这种方式适用于 id 递增的情况。

**(2)** ***\*使用 id 限定优化\*******\*---\****这种方式假设数据表的id是连续递增的，则我们根据查询的页数和查询的记录数可以算出查询的id的范围，可以使用 id between and 来查询

(3) 当然还可以使用 in 的方式来进行查询，这种方式经常用在多表关联的时候进行查询，使用其他表查询的id集合，来进行查询

 

### 聚簇索引和非聚簇索引 

聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

 

### 索引覆盖 

(1) 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。

(2) 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。

一个包含查询所需字段的索引称为“覆盖索引”

MySQL只需要通过索引就可以返回查询所需要的数据，而不必在查到索引之后进行回表操作，减少IO，提高了效率

 

 

### 算法：下一个排列

 

 

solr怎么用的，zookeeper怎么用的 

如何保证solr与数据库一致性 

### DNS递归和迭代 

一、主机向本地域名服务器的查询一般都是采用递归查询。

​    所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，

 

​    向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。

​    因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。



#### 二、本地域名服务器向根域名服务器的查询的迭代查询。

​    迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。

​    然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。

​    顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。

​    最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机

 

## CAS原理，ABA问题，解决方法 

 

volatile只能保证可见性，不能保证原子性。

但原子类（AtomicInteger等可以保证原子性），原子类利用volatile+CAS来保证原子性

CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

 

#### CAS原理

独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。

 

CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。

 

### CAS存在的问题

 

##### CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作

 

1. ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。

   

从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。



2. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率

 

3. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。

 

 

### Dubbo原理 

#### 注册中心宕机怎么办 

### RPC分为哪几部分 

#### Linux常用命令，让我按要求查日志，就是grep，cut，啥的 

 

cat 查看文件  cat 文件名 ——一次显示整个文件的内容

将几个文件合并为一个文件

$cat file1 file2 > file

grep 搜索

用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。

ps -ef | grep redis   查找指定进程

从文件中查找关键词

Grep “cat” 文件名

搜索log目录下卡号为：“4563513600036385540”,在哪个文件的具体位置及行数

grep -rin “4563513600036385540” log/

Cut 剪切文件

cut命令是一个选取命令，其功能是将文件中的每一行”字节” ”字符” ”字段” 进行剪切，选取我们需要的，并将这些选取好的数据输出至标准输出

Cut  -c 文件名  以字符为单位进行分割

Cut -d 文件名   默认制表符分割

 

ES倒排索引 

算法： 

\1. 一个字符串数组，按长度大小，相同长度按字典顺序 

字符数组排序

public static void sortString(String[] arr) {
  for (int i = 0; i < arr.length - 1; i++) {
    for (int j = i + 1; j < arr.length; j++) {
      if (arr[i].compareTo(arr[j]) > 0)  //字符串比较  arr[i].compareTo(arr[j]) 
      **swap**(arr, i, j);
    }
  }
}

 

2.EXCEL数字转字母

 



生活中你是怎样的人

举个例子

了解作业帮吗

说说你的缺点

说说你觉得经历过比较困难的时间

有看非技术的书吗，推荐下，

介绍下*本书讲了什么

对未来的规划

想来北京发展吗等等

 



一面： 

### 一棵m阶的B-tree(m叉树)：树中每个结点至多()个孩子，除根结点和叶子结点外，其它每个结点至少有()个孩子 B 树又叫平衡多路查找树。一棵m阶的B 树 (m叉树)的特性如下：

1. 树中每个结点最多含有m个孩子（m>=2）；

2. 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；

3. 若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；

4. 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；

5. 每个非终端结点中包含有n个关键字信息： (P1，K1，P2，K2，P3，......，Kn，Pn+1)。其中：

​    a)  Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki。 

​    b)  Pi为指向子树根的接点，且指针P(i)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 

​    c)  关键字的个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。



### 二进制1101.01转化成十进制 

 

## 快速排序的平均时间复杂度和最坏时间复杂度是多少 

### 排序算法的时间复杂度



### (7<<1)&15运算后的结果是 



### TCP/IP协议栈(说的越多越好) 

那为什么要叫TCP/IP协议栈内，这些协议和栈有什么关系呢，大家应该都知道栈是一种先进后出的数据结构，那这和TCP/IP协议有什么关系呢？我们就拿一个HTTP报文来说吧，HTTP报文属于应用层协议的报文，我们输入网址，首先会调用到DNS协议（域名协议，后面会讲到），然后把我们输入的网址转换为IP地址，这个IP地址大致就相当于现实生活中每个人的身份证一样，是每个网页唯一的标识，关于IP地址，后续我会详细介绍，IP协议属于网络层的协议。我们先将HTTP报文压入一个栈中（就好像是在分装报文），然后是IP，不对，我们貌似漏了一个传输层啊，别急别介，HTTP报文在传输层用的是TCP协议，好，我们把TCP压入栈中，再讲IP层也压入栈中，至于链路层的话，就用最常见的以太网就OK了，好了，现在我们的栈里面从头至尾依次是以太帧头-IP协议-TCP协议-HTTP协议，然后我们先忽略最底层的物理层，假设这个封装好的栈一样的报文漂洋过海，来到了它的目的地（至于怎么过来的，我们后续也会讲到），当对端收到这个报文以后，也就是我们封装好的这个栈一样的东西以后该怎么办呢？会不会也是先拿HTTP呢？因为这个报文是我们构造的一个栈，所以说它的顺序肯定也是栈，因此拿取的顺序就是以太帧头-IP协议-TCP协议-HTTP协议，发现没，最先被封装入的HTTP报文是最后才被拿出来的，这中间的细节如果能全部掌握，那基本商就算是入门了，关于这部分东西，我会在后面详细介绍，现在有这个概念就可以了。

 



### 二面： 

#### 说一下你项目中遇到的最大的问题，如何解决的（再次把我毫不相关的科研项目扯了一通） 

堆和栈 

### const和define的区别 

### Linux用过吗 

#### 一个文件里面有很多ip地址，如何用grep命令查看出现次数最多的三个？用awk呢？ 

awk  wk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。

awk 'BEGIN{ commands } pattern{ commands } END{ commands }'

- 第一步：运行BEGIN{ commands }语句块中的语句。

- 第二步：从文件或标准输入(stdin)读取一行。然后运行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行反复这个过程。直到文件所有被读取完成。

- 第三步：当读至输入流末尾时，运行END{ commands }语句块。



BEGIN语句块在awk開始从输入流中读取行之前被运行，这是一个可选的语句块，比方变量初始化、打印输出表格的表头等语句通常能够写在BEGIN语句块中。

END语句块在awk从输入流中读取全然部的行之后即被运行。比方打印全部行的分析结果这类信息汇总都是在END语句块中完毕，它也是一个可选语句块。

可用awk来统计固定格式日志里的一些数据，如日志中出现过所有不同的IP

awk ‘{i=$1;count[i]++}END{for(i in count)print(i,count[i])}’ /var/log/httpd/access_log

awk对文件进行流处理，每次读取一行。$1就是IP，count[i]++是将IP作为一个数组的下标，并且使得统计这个IP所对应的数组元素自增

也可以用来找出访问次数最多的ip。

awk '{a[$1] += 1;} END {for (i in a) printf("%d %s\n", a[i], i);}' 日志文件 | sort -n | tail -n 10 **#用tail显示最后10行**

有一个文件ip.txt，每行一条ip记录，共若干行，下面哪个命令可以实现“统计出现次数最多的前3个ip及其次数”？

sort ip.txt | uniq -c | sort -rn | head -n 3

root用户如何修改文件的所属人？谈到了chmod命令 

chmod作用：修改文件、目录的权限

有两种方式修改权限

（1）+ 、-、= 变更权限 

 u：所有者 g:所在组 o：其他组 a：所有人(u、g、o的总和) 

① chmod  u=rwx, g=rx, o=x  文件目录名 

② chmod  o+w  文件目录名 给其他组的用户增加写的权限

③ chmod  a-x   文件目录名 给所有人去掉可执行文件的权限

 





### 算法题： 

面试官说有一道简单的，一道难一点的，让我自己选择，因为前面linux命令那块答得不太好，就选了难的那道 

给出一个字符串S，牛牛想知道这个字符串有多少个子序列等于"niuniu"
子序列可以通过在原串上删除任意个字符(包括0个字符和全部字符)得到



```java

public class niuniuString {
    /**
     * 给出一个字符串S，牛牛想知道这个字符串有多少个子序列等于"niuniu"
     * 子序列可以通过在原串上删除任意个字符(包括0个字符和全部字符)得到
     */
    public static void main(String[] args) {
        String str = "yrabbbit";
        String str2 = "rabbit";
        int i = numDistinct(str, str2);
        System.out.println(i);

    }


    public static int numDistinct(String S, String T) {
        if(S==null&&T==null)
            return 1;
        if(S==null&&T!=null)
            return 0;
        if(S!=null&&T==null)
            return 1;
        int[][]dp=new int[S.length()+1][T.length()+1];

        dp[0][0]=1;
        for(int i=1;i<=S.length();i++){
            dp[i][0]=1;
        }
        for(int i=1;i<=T.length();i++){
            dp[0][i]=0;
        }

        for(int i=1;i<=S.length();i++){
            for(int j=1;j<=T.length();j++){
                if(S.charAt(i-1)!=T.charAt(j-1)){
                    dp[i][j]=dp[i-1][j];
                }
                else{
                    dp[i][j]=dp[i-1][j]+dp[i-1][j-1];
                }
            }
        }
        
        for (int i =0;i<dp.length;i++){
            for (int j = 0; j < dp[0].length; j++) {
                System.out.print(dp[i][j]+" ");
            }
            System.out.println();
        }
        return dp[S.length()][T.length()];
    }
}

```





#### 求子串的长度算法



```java

public class StringDemo {
    public static void main(String[] args) {
        String str = "vrabbbit";
        String str2 = "rabbit";
        int i = childString(str, str2);
        System.out.println(i);
    }

    public static int childString(String s1,String s2){
        if (s1 == null && s2 == null) {
            return 1;
        }
        if (s1 == null && s2 != null) {
            return 0;
        }

        int[][] result = new int[s1.length()+1][s2.length()+1];

        for (int i = 0; i < result.length; i++) {
            for (int j = 0; j < result[0].length; j++) {
                System.out.print(result[i][j]+" ");
            }
            System.out.println();
        }

        for (int i = 1; i < result.length; i++) {
            for (int j = 1; j < result[1].length; j++) {
                if (s1.charAt(i-1) == s2.charAt(j-1)) {
                    result[i][j] = result[i-1][j-1]+1;
                }else {
                    if (result[i][j - 1] >= result[i - 1][j]) {
                        result[i][j] = result[i][j-1];
                    }else {
                        result[i][j] = result[i-1][j];
                    }
                }
            }
        }
        return result[s1.length()][s2.length()];
    }
}

```



 

### 3、linux命令（我平时不太用linux就只知道哪些情况用什么命令但是具体参数不太知道；问了查找文件里关键词最多的怎么查，还有查找进程名为live的进程等等 

 

grep -count 文件名称   | tail 10

 

### 4、数据库查找stu表内名字为lily，住址包含北京的信息，按年龄降序排序；我开始是select *然后要求只查住址列怎么办？然后问我修改包含北京的列里北京两个字为上海怎么办（replace我没用过... 





### int和Integer的区别，为什么有了int还需要Integer

 

### ArrayList和LinkedList区别，各有什么特点

 

### 进程和线程的区别，联系

 

### 多线程编程，死锁检测与预防，死锁的检测手段，怎样避免死锁

 

### 讲一讲线程池，讲讲为什么很多公司对于线程池的使用非常谨慎

 

### SQL代码书写：有一个学生信息表包含id，学号，选修课程和该课程的成绩，写一个SQL语句来查找总分最高的前十名同学。

 

### 建表过程中索引添加的规范

 

### InnoDB的4种事务隔离级别

 

### SSM和Spring Boot的比较，Spring Boot的缺点(没答上来，面试官的解释是Spring Boot封装层数过多导致的性能问题)

 

### 假如有10亿个手机号，怎么样快速判断一个手机号是否在其中(一开始没什么好的思路，面试官一步一步从hash，二分，布隆过滤器引导到位图)

 

### 机智题：烧完一整根香需要30分钟，怎么样得到15分钟的计时，怎么样得到7.5分钟的计时

 

 

### 算法题：把数组中奇数放在前面，偶数放在后面，并且奇数偶数都要保证从小到大，要求空间复杂度O(1)

 

### MySQL索引结构，说说B树和B+树的区别

 

### MySQL索引什么时候失效，联合索引，聚集索引

### 聚集索引：

聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据。聚集索引的叶子节点称为数据页，每个数据页通过一个双向链表来进行链接，而且数据页按照主键的顺序进行排列。

 

## 辅助索引：

辅助索引(二级索引)：叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录。

覆盖索引：

当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫 做覆盖索引。

 

 

#### 写一个单例模式

 

Redis数据结构，场景题

 

讲讲Java的堆内存、GC

Java把内存分成两种，一种叫做栈内存，一种叫做堆内存，有着不同的作用。栈内存用来存储局部变量和方法调用。
栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。
而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。

引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，***\*数\****组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!

 

### 说说抽象类和接口的区别

- 相同点：都不能被实例化

- 区别一，两者表达的概念不一样。抽象类是一类事物的高度聚合，那么对于继承抽象类的子类来说，对于抽象类来说，属于“是”的关系；而接口是定义行为规范，因此对于实现接口的子类来说，相对于接口来说，是“行为需要按照接口来完成”。

 

- 区别二，抽象类在定义类型方法的时候，可以给出方法的实现部分，也可以不给出；而对于接口来说，其中所定义的方法都不能给出实现部分。

 

- 区别三，继承类对于两者所涉及方法的实现是不同的。继承类对于抽象类所定义的抽象方法，可以不用重写，也就是说，可以延用抽象类的方法；而对于接口类所定义的方法或者属性来说，在继承类中必须要给出相应的方法和属性实现。

 

- 区别四，在抽象类中，新增一个方法的话，继承类中可以不用作任何处理；而对于接口来说，则需要修改继承类，提供新定义的方法。

 





 

写程序。排序。要求奇数放到前面，偶数放到后面(空间复杂度o(1)) 

 

一次http请求过程发生了什么 

 

springmvc处理过程(http请求服务端发生了那些) 

（1）我们应该都知道在启动一个Spring MVC项目的时候，我们要在web.xml配置文件中声明DispatcherServlet。如下图的web.xml所示，这个Servlet监听的URL是*模式，这意味着所有的请求都能通过DispatcherServlet。

URL匹配模式是非常重要的，如果请求符合DispatcherServlet配置的URL模式,那么这个请求就会被处理，否则就不会。DispatcherServlet根据URL请求的地址把请求传给指定的controller。那么DispatcherServlet是如何知道请求要传给哪个controller的呢？ 

 

使用@RequestMapping注解或者Spring MVC配置文件，可以找到URL请求的controller。当然也可以用特定的请求注解，比如@GetMapping或PostMapping。controller文件必须使用@Controller或@RestController(Restful风格)注解进行标记。

最后，总结一下Spring MVC处理HTTP请求的过程 

1.客户端发送HTTP请求到指定的URL。 

2.Spring MVC的DispatcherServlet接收到请求 

3.DispatcherServlet把请求传到用@Controller和@RequestMapping注解的controller 

4.Spring MVC返回逻辑视图的名称和模型给DispatcherServlet 

5.DispatcherServlet咨询视图处理器直到有实际的视图来展示数据为止 

6.DispatcherServlet使用模型数据联系所选的视图，例如Thymeleaf,Freemarker,JSP,并根据数据模型呈现输出。 

7.呈现的输出作为响应返回给客户端 

以上就是Spring MVC的工作流程或者说Spring MVC处理HTTP请求的过程。

 

 

mybatis执行过程，原理 

 

怎么转换成html了。(没怎么写过前端，都是传json数据) 

 

为什么握手是三次 

 

数据库索引用的什么结构。b 树比b树有什么优势 

 

最左前缀(数据库自己的优化) 

 

单例模式 

 

session和cookie 

 

JAVA垃圾回收 

二面 

分享一个你觉得比较有的讲得实习经历(五分钟) 

怼项目(十分钟) 

JAVA是自学的还是开的课程 

学习JAVA你怎么学习的 

JAVA虚拟机内存模型 

syn和lock 

可重入锁实现原理

事务用来做什么 

lru 

网络方面TCP断开time_wait(什么时候进入这种状态，为什么要有这种状态) 

快排 

对工作的方向对语言有要求吗 

看你学JAVA很多，是因为这方面需求比较大吗 

平时得工作环境在Linux吗

统计某个字符串的行数统计用什么命令 

Grep -count “字符串” 文件名称

统计某个文件的行数

Wc 文件名   显示行数  字数  字节数

有什么要问我的吗？

 

MYSQL日志分为几种

如何保证回滚


数据库中事务到底是mvcc回滚还是日志回滚
socket有几种状态
mysql更新了数据日志文件有什么改变
它的意思是服务器崩了，你访问服务器应该是什么样
服务器崩了发送什么错误码，崩了情况下500是谁发的
开发环境和生产环境不一样，配置环境应该有什么不同配置数据库
ACID
死锁以及解决措施
rabbitmq中各种模式
堆栈区别
GC回收算法
点击按钮这个过程详解一下

算法题：
长字符串相加
nums[] = {1,-1,0,2,-2,1,3} 找到所有不重复a + b + c = 0

 